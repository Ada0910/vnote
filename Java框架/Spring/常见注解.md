# 1. @MapperScan
之前是在配置中都是要引入@Mapper这个来给每一个mapper类进行配置，显得有点麻烦和冗余
## 1.1. 配置一个

通过使用@MapperScan可以指定要扫描的Mapper类的包的路径,比如:

```
@SpringBootApplication
@MapperScan("com.ada.web.mapper")
// 添加对mapper包扫描
public class Application {
	public static void main(String[] args) {
		SpringApplication.run(Application.class, args);
	}

}
```
## 1.2. 配置多个
同时,使用@MapperScan注解多个包

```
@SpringBootApplication  
@MapperScan({"com.ada.web","com.ada.user"})  
public class App {  
    public static void main(String[] args) {  
       SpringApplication.run(App.class, args);  
    }  
} 

```
## 1.3. 非常规情况
如果如果mapper类没有在Spring Boot主程序可以扫描的包或者子包下面，可以使用如下方式进行配置

```
@SpringBootApplication  
@MapperScan({"com.ada.*.mapper", "com.ada.*.mapper"})  
public class App {  
    public static void main(String[] args) {  
       SpringApplication.run(App.class, args);  
    }  
} 

```

# 2. @GetMapping
Spring4.3中引进了｛@GetMapping、@PostMapping、@PutMapping、@DeleteMapping、@PatchMapping｝，来帮助简化常用的HTTP方法的映射，并更好地表达被注解方法的语义。
  以@GetMapping为例，Spring官方文档说：
  @GetMapping是一个组合注解，是@RequestMapping(method = RequestMethod.GET)的缩写。该注解将HTTP Get 映射到 特定的处理方法上

# 3. @RequestParam
GET和POST请求传的参数会自动转换赋值到@RequestParam 所注解的变量上
@RequestParam 和 @PathVariable 注解是用于从request中接收请求的，两个都可以接收参数，关键点不同的是@RequestParam 是从request里面拿取值，而 @PathVariable 是从一个URI模板里面来填充

- @RequestParam
看下面一段代码：

```
http://localhost:8080/springmvc/hello/101?param1=10&param2=20
```

根据上面的这个URL，你可以用这样的方式来进行获取

```
public String getDetails(
    @RequestParam(value="param1", required=true) String param1,
        @RequestParam(value="param2", required=false) String param2){
...
}

```
@RequestParam 支持下面四种参数

defaultValue 如果本次请求没有携带这个参数，或者参数为空，那么就会启用默认值
name 绑定本次参数的名称，要跟URL上面的一样
required 这个参数是不是必须的
value 跟name一样的作用，是name属性的一个别名
# 4. @RequestBody

<<<<<<< HEAD
@RequestBody注解可以接收json格式的数据，并将其转换成对应的数据类型。

1. @RequestBody接收一个对象
url请求：http://localhost:8080/WxProgram/findBookByName

复制代码
=======

- @RequestParam（org.springframework.web.bind.annotation.RequestParam）用于将指定的请求参数赋值给方法中的形参。
例：
(1) get请求：

url请求：http://localhost:8080/WxProgram/findAllBookByTag?tagId=1&pageIndex=3

```
userTest.jsp

<form action="/WxProgram/json/requestParamTest" method="get">
    requestParam Test<br>
    用户名：<input type="text" name="username"><br>
    用户昵称：<input type="text" name="usernick"><br>
    <input type="submit" value="提交">
</form>
```

```
UserController.java

    @RequestMapping(value="/requestParamTest", method = RequestMethod.GET)
    public String requestParamTest(@RequestParam(value="username") String userName, @RequestParam(value="usernick") String userNick){
        System.out.println("requestParam Test");
        System.out.println("username: " + userName);
        System.out.println("usernick: " + userNick);
        return "hello";
    }
```

上述代码会将请求中的username参数的值赋给username变量。

等价于：

```
    @RequestMapping(value="/requestParamTest", method = RequestMethod.GET)
    public String requestParamTest(String username, HttpServletRequest request){
        System.out.println("requestParam Test");
        System.out.println("username: " + username);
        String usernick = request.getParameter("usernick");
        System.out.println("usernick: " + usernick);
        return "hello";
    }
```

也可以不使用@RequestParam，直接接收，此时要求controller方法中的参数名称要跟form中name名称一致


```
    @RequestMapping(value="/requestParamTest", method = RequestMethod.GET)
    public String requestParamTest(String username, String usernick){
        System.out.println("requestParam Test");
        System.out.println("username: " + username);
        System.out.println("usernick: " + usernick);
        return "hello";
    }
```

- 总结：

接收请求参数的方式：

```
@RequestParam(value="username") String userName, @RequestParam(value="usernick") String userNick //value中的参数名称要跟name中参数名称一致
String username, String usernick// 此时要参数名称一致
HttpServletRequest request //request.getParameter("usernick")
```
-  post请求：
跟get请求格式一样，只是把方法中的get换成post

@RequestParam
用来处理Content-Type: 为 application/x-www-form-urlencoded编码的内容。提交方式为get或post。（Http协议中，如果不指定Content-Type，则默认传递的参数就是application/x-www-form-urlencoded类型）

RequestParam实质是将Request.getParameter() 中的Key-Value参数Map利用Spring的转化机制ConversionService配置，转化成参数接收对象或字段。

get方式中query String的值，和post方式中body data的值都会被Servlet接受到并转化到Request.getParameter()参数集中，所以@RequestParam可以获取的到
# 4. @RequestBody

@RequestBody注解可以接收json格式的数据，并将其转换成对应的数据类型。

-  @RequestBody接收一个对象
url请求：http://localhost:8080/WxProgram/findBookByName
>>>>>>> adf3157d34b3e8f552aa78559a5e35272090013e
```
@RequestMapping(value="/findBookByName", method = RequestMethod.POST)
@ResponseBody
public DbBook findBookByName(@RequestBody DbBook book){
    System.out.println("book: " + book.toString());
    System.out.println("book name: " + book.getTitle());
    String bookName = book.getTitle();
    DbBook book = wxService.findBookByName(bookName);    
    return book;
}
```
<<<<<<< HEAD
复制代码
=======
>>>>>>> adf3157d34b3e8f552aa78559a5e35272090013e

- @RequestBody接收不同的字符串

(1)前台界面，这里以小程序为例

<<<<<<< HEAD
复制代码
=======
>>>>>>> adf3157d34b3e8f552aa78559a5e35272090013e
```
wx.request({
      url: host.host + `/WxProgram/deleteBookById`,
      method: 'POST',
      data: {
        nick: this.data.userInfo.nickName,
        bookIds: bookIds
      },
      success: (res) => {
        console.log(res);
        this.getCollectionListFn();
      },
      fail: (err) => {
        console.log(err);
      }
    })
```
<<<<<<< HEAD
复制代码

- controller

复制代码
=======

(2)controller

>>>>>>> adf3157d34b3e8f552aa78559a5e35272090013e
```
@RequestMapping(value="/deleteBookById",method=RequestMethod.POST)
@ResponseBody
public void deleteBookById(@RequestBody Map<String, String> map){
    String bookIds = map.get("bookIds");
    String nick = map.get("nick");
    String[] idArray = bookIds.split(",");
    Integer userId = wxService.findIdByNick(nick);
    for(String id : idArray){
        Integer bookid = Integer.parseInt(id);
        System.out.println("bookid: " + bookid);
        wxService.removeBookById(bookid, userId);
    }
}
```
<<<<<<< HEAD
复制代码
=======
>>>>>>> adf3157d34b3e8f552aa78559a5e35272090013e
@RequestBody
处理HttpEntity传递过来的数据，一般用来处理非Content-Type: application/x-www-form-urlencoded编码格式的数据。

GET请求中，因为没有HttpEntity，所以@RequestBody并不适用。
POST请求中，通过HttpEntity传递的参数，必须要在请求头中声明数据的类型Content-Type，SpringMVC通过使用HandlerAdapter 配置的HttpMessageConverters来解析HttpEntity中的数据，然后绑定到相应的bean上。

<<<<<<< HEAD
@RequestBody用于post请求，不能用于get请求
=======
- @RequestBody用于post请求，不能用于get请求
>>>>>>> adf3157d34b3e8f552aa78559a5e35272090013e

这里涉及到使用@RequestBody接收不同的对象
1. 创建一个新的entity，将两个entity都进去。这是最简单的，但是不够“优雅”。
2. 用Map<String, Object>接受request body，自己反序列化到各个entity中。
3. 类似方法2，不过更为generic，实现自己的HandlerMethodArgumentResolver
<<<<<<< HEAD
# 5. @PathVariable
请求路径上有个id的变量值，可以通过@PathVariable来获取  @RequestMapping(value = "/page/{id}", method = RequestMethod.GET)

# 6. @Param
=======
# 5. @ModelAttribute

@ModelAttribute注解类型将参数绑定到Model对象

userTest.jsp
```
<form action="/WxProgram/json/modelAttributeTest" method="post">
    modelAttribute Test<br>
    用户id：<input type="text" name="userId"><br>
    用户名：<input type="text" name="userName"><br>
    用户密码：<input type="password" name="userPwd"><br>
    <input type="submit" value="提交"><br>
</form>
```
name的属性值要跟User的属性相对应。
 UserController.java

```
@RequestMapping(value="/modelAttributeTest", method = RequestMethod.POST)
    public String modelAttributeTest(@ModelAttribute User user){
        System.out.println("modelAttribute Test");
        System.out.println("userid: " + user.getUserId());
        System.out.println("username: " + user.getUserName());
        System.out.println("userpwd: " + user.getUserPwd());
        return "hello";
    }
```
 User.java

```
public class User {
    private Integer userId;
    private String userName;
    private String userPwd;
    
    public User(){
        super();
    }
        //setter and getter      
}
```
当前台界面使用GET或POST方式提交数据时，数据编码格式由请求头的ContentType指定。分为以下几种情况：
1. application/x-www-form-urlencoded，这种情况的数据@RequestParam、@ModelAttribute可以处理，@RequestBody也可以处理。
2. multipart/form-data，@RequestBody不能处理这种格式的数据。（form表单里面有文件上传时，必须要指定enctype属性值为multipart/form-data，意思是以二进制流的形式传输文件。）
3. application/json、application/xml等格式的数据，必须使用@RequestBody来处理
# 6. @PathVariable
请求路径上有个id的变量值，可以通过@PathVariable来获取  @RequestMapping(value = "/page/{id}", method = RequestMethod.GET)

# 7. @Param
>>>>>>> adf3157d34b3e8f552aa78559a5e35272090013e
dao层示例

```
Public User selectUser(@param(“userName”) String name,@param(“userpassword”) String password);
```

xml映射对应示例

```

<select id=" selectUser" resultMap="BaseResultMap">  
   select  *  from user_user_t   where user_name = #{userName，jdbcType=VARCHAR} and user_password=#{userPassword,jdbcType=VARCHAR}  
</select>
```

注意：采用#{}的方式把@Param注解括号内的参数进行引用（括号内参数对应的是形参如 userName对应的是name）；

- @Param注解JavaBean对象

dao层示例

```
public List<user> getUserInformation(@Param("user") User user);

```
xml映射对应示例


```
<select id="getUserInformation" parameterType="com.github.demo.vo.User" resultMap="userMapper">  
        select   
        <include refid="User_Base_Column_List" />  
        from mo_user t where 1=1  
                      <!-- 因为传进来的是对象所以这样写是取不到值得 -->  
            <if test="user.userName!=null  and user.userName!=''">   and   t.user_name = #{user.userName}  </if>  
            <if test="user.userAge!=null  and user.userAge!=''">   and   t.user_age = #{user.userAge}  </if>  
    </select>  

```

- 使用@Param注解

当以下面的方式进行写SQL语句时：

```
    @Select("select column from table where userid = #{userid} ")
    public int selectColumn(int userid);
```

当你使用了使用@Param注解来声明参数时，如果使用 #{} 或 ${} 的方式都可以。

```
    @Select("select column from table where userid = ${userid} ")
    public int selectColumn(@Param("userid") int userid);
```

当你不使用@Param注解来声明参数时，必须使用使用 #{}方式。如果使用 ${} 的方式，会报错。

```
    @Select("select column from table where userid = ${userid} ")
    public int selectColumn(@Param("userid") int userid);

```


- 不使用@Param注解

不使用@Param注解时，参数只能有一个，并且是Javabean。在SQL语句里可以引用JavaBean的属性，而且只能引用JavaBean的属性。

```
    // 这里id是user的属性

    @Select("SELECT * from Table where id = ${id}")
    Enchashment selectUserById(User user);

```

<<<<<<< HEAD
# 7. @Component 
指示自动扫描组件。
# 8. @Repository 
表示在持久层DAO组件。
# 9. @Service 
表示在业务层服务组件。
## 9.1. 例如
=======
# 8. @Component 
指示自动扫描组件。
# 9. @Repository 
表示在持久层DAO组件。
# 10. @Service 
表示在业务层服务组件。
## 10.1. 例如
>>>>>>> adf3157d34b3e8f552aa78559a5e35272090013e
首先，在applicationContext.xml文件中加一行：
```
<context:component-scan base-package="xxx"/> 
```
加上这一行以后，将自动扫描路径下面的包，如果一个类带了@Service注解，将自动注册到Spring容器，不需要再在applicationContext.xml文件定义bean了，类似的还包括@Component、@Repository、@Controller
```
@Service("courseDAO")
@Scope("prototype")
public class CourseDAOImpl extends HibernateDaoSupport implements CourseDAO{

    ......
    
}
其作用就相当于applicationContext.xml文件里面的：

<bean id="courseDAO"
         class="com.hzhi.course.dao.CourseDAOImpl" scope="prototype">
         ......    
    </bean>
```

<<<<<<< HEAD
# 10. @Controller 
表示在表示层控制器组件

# 11. @Autowired  
=======
# 11. @Controller 
表示在表示层控制器组件

# 12. @Autowired  
>>>>>>> adf3157d34b3e8f552aa78559a5e35272090013e
当不能确定 Spring 容器中一定拥有某个类的 Bean 时，可以在需要自动注入该类 Bean 的地方可以使用 @Autowired(required = false)，这等于告诉 Spring：在找不到匹配 Bean 时也不报错