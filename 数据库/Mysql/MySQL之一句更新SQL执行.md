# 1. 一句更新SQL执行
流程基本和查询基本一致，主要是在拿到符合条件的数据之后的操作
# 2. 缓存池 Buffer Pool
- 首先，对于InnoDB的存储引擎来说，数据都是放在磁盘上面的，必须先把磁盘里面的数据加载到内存里面才可以操作
- 这里可能就有个问题，是不是我们需要的数据多大，就要一次从磁盘加载多少数据到内存？磁盘IO的读写对于内存来说是很慢的 ，那么如果我们需要的数据在磁盘的不同的地方，是不是就意味着有很多次的IO操作？
- 所以，无论是操作系统也好，还是存储引擎也好，都有一个预读取的概念，也就是说，当磁盘上的一块数据被读取的时候，很有可能它附近的位置也会马上被读取到，这个就叫做局部性原理，那么这样，我们干脆每次多读取一点，而不是用多少读多少
- InnoDB中设定了一个存储引擎从磁盘上读取数据到内存的最小单位，叫做页（操作系统一般是4k，而InnoDB中默认是16k，可以修改，但必须修改源码重新编译安装）
- 我们要操作的数据就在这样的页里面了，数据所在的页叫数据页
- InnoDB使用了一种缓冲池的技术，也就是把磁盘读取到的页放在一块内存区域里面，下次读取相同的页的时候，先判断内存区域中是否有，如果有，直接读取，不用从磁盘加载，这个内存区域就叫Buffer Pool
-  修改数据的时候，是先修改内存缓冲池里面的页，内存的数据页和磁盘数据不一致的时候，我们就叫他做脏页，后台有专门讲buffer pool的数据写入磁盘，这个动作叫刷脏
## 2.1. Buffer Pool
- 查看buffer pool中的缓存的page页面信息
```
show status like "%buffer_pool%"
```
![](_v_images/20200607161233632_25676.png =1822x)

- 查看参数
```
show VARIABLES like "%buffer_pool%"
```
![](_v_images/20200607162416911_22825.png =1816x)

## 2.2. （redo）Log Buffer
- 因为刷脏不是实时的，如果Buffer Pool里面的脏页还没有刷入磁盘的是，数据库宕机或者重启，这些数据就会丢失
- 为了避免这样的问题，InnoDB会把所有对页面的修改操作专门写入一个日志文件，如果有未同步到磁盘的数据，数据库在启动的时候，会从这个日志文件进行恢复操作，我们说事务中的ACID中的D（持久性），就是用它来实现的
![](_v_images/20200607193032704_27283.png =938x)
这个日志文件就是磁盘的redo log(叫做重做日志)
![](_v_images/20200607195356769_30647.png =1938x)
- 既然是写磁盘，为啥不直接写到db_file里面，而要先写日志再写磁盘？写日志文件和写到数据文件有啥区别？

刷盘是随机的IO,而记录日志是顺序IO，顺序IO效率更高，因此先把修改的写入日志，在保证内存数据的安全性的情况下，可以延迟刷盘时机，进而提升了系统的吞吐

### 2.2.1. redo log
-  redo log是InnoDB存储引擎实现的，并不是所有引擎都有，支持崩溃恢复是InnoDB的一个特性
- redo log是物理日志，记录的是“某个数据页上做了什么修改”
- redo log是大小固定的，前面的内容会被覆盖，一旦写满，就会触发buffer pool到磁盘的同步，以便腾出空间记录后面的修改
- redo log 的内容主要是用于崩溃恢复

### 2.2.2. undo log
- 也是和修改有关的日志（和redo log称为事务日志）
- undo log（撤销日志或者回滚日志）记录了事务发生之前的数据状态（不包括select），如果修改数据时出现异常，可以用undo log来实现回滚操作（保持原子性）
- 在执行undo的时候，仅仅是将数据从逻辑上恢复至事务之前的状态，而不是从物理上页面上操作实现的，属于逻辑格式的日志
```
show GLOBAL VARIABLES like "%undo%"
```
![](_v_images/20200607224810147_22101.png =930x)

### 2.2.3. 更新语句流程
```
update user set name = "ada" where id = 1
```
- 事务开始，buffer pool获取磁盘读取到了这条数据，返回给Server的执行器
- Server的执行器修改这一行的值为Ada
- 记录name = ada 到undo log
- 记录name= ada 到redo log
- 调用存储引擎的接口，在buffer pool中修改name = ada
- 事务提交
### 2.2.4. Bin log
- MySQL的Server层也有一个日志文件，她可以被所有存储引擎使用
- 属于逻辑日志，用来做主从复制和数据恢复的
- 与redolog不一样的，他的内容是可以追加的，没有固定大小限制
- 在开启binlog的功能下，我们可以把binlog导出成SQL语句，把所有的操作重放一边，来实现数据的归档恢复
- binlog的另一个功能是用来实现主从复制
![](_v_images/20200607225732210_24590.png =1172x)

### 2.2.5. 更新语句（binlog）
![](_v_images/20200607225906634_2713.png =1288x)
